#!/usr/bin/env python


import os
import sys
import vcf
import argparse
import pysam
import collections
import re


class Consensus():
    """
    A class for handling consensus genomes in FASTA format
    """
    def __init__(self, fasta):
        self.fasta = fasta

    def count_bases(self):
        """
        Count the number of Ns in a consensus sequence
        """
        fa = pysam.FastxFile(self.fasta)
        for record in fa:
            base_counter = collections.Counter()
            for base in record.sequence:
                base_counter.update(base.upper())
        self.base_count = base_counter

    def get_sequence_length(self):
        """
        Return the length of the sequence
        """
        fa = pysam.FastxFile(self.fasta)
        seq_length = list()
        for record in fa:
            seq_length.append(len(record.sequence))
        if len(seq_length) > 1:
            print("Multiple sequences found: there should only be one sequence")
            sys.exit(1)
        return seq_length[0]

    def calculate_completeness(self):
        """
        Determine the genome completeness
        """
        total = 0
        for base, count in self.base_count.items():
            total += count
        self.completeness = 1 - (float(self.base_count['N']) / total)


def get_frameshift_indel(var):
    """
    Get the frameshift insertions and deletions from the
    SNPEff annotated VCF file.
    """
    pass


def init_args():
    """
    Initialize the command line arguments
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('-v', '--vcf', required=True,
            help='full path to the VCF file to process')
    parser.add_argument('-f', '--fasta', required=True,
            help='full path to the FASTA file to process')
    parser.add_argument('-s', '--sample', required=True,
            help='name of the sample being processed')
    return parser.parse_args()


def import_variants(file):
    """
    Import the variants in a VCF file generated by quick_align.py and
    annotated by a consequence caller
    """
    variants = list()
    with open(file, 'r') as ifh:
        for line in ifh:
            if line.startswith('##'):
                # skip the first line
                continue


def is_variant_N(var):
    """
    Determine whether the variant is a stretch of Ns
    """
    pass
    #var_list = list(set(var.ALT[0]))
    #if len(var_list) == 1:
    #    return True
    #else:
    #    return False


def is_variant_indel(var):
    """
    Returns a boolean if the variant is an indel
    """
    if len(str(var.ALT[0])) > 1 or len(str(var.REF)) > 1:
        return True
    else:
        return False


def is_insertion(var):
    """
    Returns a boolean if the variant is an insertion
    """
    if len(str(var.ALT[0])) > len(str(var.REF)):
        return True
    else:
        return False


def is_deletion(var):
    """
    Returns a boolean if the variant is a deletion
    """
    if len(str(var.REF)) > len(str(var.ALT[0])):
        return True
    else:
        return False


def is_frameshift(var):
    """
    Returns a boolean if the variant is a frameshift indel
    """
    if 'ANN' in var.INFO:
        if re.search('frameshift', var.INFO['ANN'][0]):
            return True
    return False


def print_header(delimiter='\t'):
    """
    Print the column headers
    """
    print(delimiter.join([
        "sample",
        "total_n",
        "total_snp",
        "total_insertion",
        "total_deletion",
        "total_frameshift",
        "completeness"]))


def print_data(variants, delimiter='\t'):
    """
    Print the variant data as columns
    """
    print(delimiter.join([
        str(variants["sample"]),
        str(variants["total_n"]),
        str(variants["total_snp"]),
        str(variants["total_insertion"]),
        str(variants["total_deletion"]),
        str(variants["total_frameshift"]),
        str(variants["completeness"])
        ]))


def separate_mutations(var):
    """
    Several mutations were identified as having multiple
    nucleotide polymorphisms, however the mixture_check.py
    script requires each mutation to be a separate line
    in the alleles.tsv file.  This function returns
    a list of variants.
    """
    var_orig = var
    variants = list()
    tmp_ref = str(var.REF)
    tmp_alt = str(var.ALT[0])
    tmp_pos = int(var.POS)
    for idx, (ref, alt) in enumerate(zip(tmp_ref, tmp_alt)):
        tmp_var = deepcopy(var)
        tmp_var.REF = ref
        tmp_var.ALT[0] = alt
        if ref == alt:
            continue
        else:
            tmp_var.POS = tmp_pos + int(idx)
            variants.append(tmp_var)
    return variants


def is_mnp(var):
    """
    Check if the mutation is a multiple nucleotide polymorphism.
    """
    if len(str(var.ALT[0])) == len(str(var.REF)) and len(str(var.ALT[0])) > 1:
        return True
    elif len(str(var.ALT[0])) != len(str(var.REF)):
        return False


def main():
    """
    The main executable
    """
    args = init_args()
    vcf_reader = vcf.Reader(filename=args.vcf)
    variant_summary = dict()
    variants = list()
    if args.sample not in variants:
        variants = {'sample': args.sample, 'total_n': 0, 'total_snp': 0,
            'total_insertion': 0, 'total_deletion': 0,
            'total_frameshift': 0, 'completeness': 0.0}
    for var in vcf_reader:
        if is_variant_N(var):
            continue
        if var.is_snp:
            variants['total_snp'] += 1
        if is_insertion(var):
            variants['total_insertion'] += 1
        if var.is_deletion:
            variants['total_deletion'] += 1
        if is_frameshift(var):
            variants['total_frameshift'] += 1

    consensus = Consensus(fasta=args.fasta)
    consensus.count_bases()
    consensus.calculate_completeness()
    variants['total_n'] = consensus.base_count['N']
    variants['completeness'] = consensus.completeness
    print_header()
    print_data(variants=variants)


if __name__ == '__main__':
    main()


#__END__
